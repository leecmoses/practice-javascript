<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Notes for ES6</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:700|Roboto:300,400,500," rel="stylesheet">
</head>

<body>
    <h1><span>&lt/&gt</span> ES6</h1>
    <div class="table">
        <h1>Contents</h1>
        <ol>
            <li><a href="#syntax">Syntax</a></li>
            <li><a href="#functions">Functions</li>
            <li><a href="#builtins">Built-ins</a></li>
            <li><a href="#developerfu">Professional Developer-fu</a></li>
        </ol>
    </div>

    <div class="section">
        <h2 id="syntax"><span>#</span> Syntax</h2>
        <div>
            <h3>1. Harmony, ES6, ES2015...</h3>
            <ul>
                <li>JS Harmony, ES6, ES2015 all refers to the same thing</li>
            </ul>
        </div>

        <div>
            <h3>2. Let and Const</h3>
            <ul>
                <li>There are two new ways to declare variables in JavaScript: <strong>let</strong> and <strong>const</strong></li>
                <li>Essentially before any JavaScript code is executed, all variables are "hoisted", which means
                    they're raised to the top of the function scope when using <strong>var</strong></li>
                <ul>
                    <li>However, variables declared with <strong>let</strong> and <strong>const</strong> eliminate this
                        specific issue of hoisting because they're scoped <strong>to the block</strong>, not to the
                        function</li>
                    <li>Previously, when variables are declared using <strong>var</strong>, variables were either
                        scoped <em>globally</em> or <em>locally</em> to an entire function scope</li>
                </ul>
                <li>If a variable is declared using <strong>let</strong> or <strong>const</strong> inside a block of
                    code (denoted by curly braces <strong>{ }</strong>, then the variable is tuck in what is known as
                    the <strong>temporal dead zone</strong> until the variable's declaration is processed</li>
                <ul>
                    <li>This behavior prevents variables from being accessed only until after they've been declared</li>
                </ul>
                <li><strong>let</strong> and <strong>const</strong> also have some other interesting properties</li>
                <ul>
                    <li>Variables declared with <strong>let</strong> can be <em>reassigned</em>, but <strong>can't</strong>
                        be <em>redeclared</em> in the same scope</li>
                    <li>Variables declared with <strong>const</strong> must be assigned an initial value, but <strong>can't</strong>
                        be <em>redeclared</em> in the same scope, and <strong>can't</strong> be <em>reassigned</em></li>
                </ul>
                <li>Use <strong>let</strong> when you plan to reassign new values to a variable, and use <strong>const</strong>
                    when you don't plan on reassigning new values to a variable</li>
                <li>There are some arguments that can be made for using <strong>var</strong> in situations where you
                    want to globally define variables, but this is often considered bad practice and should be avoided,
                    from now one ditch <strong>var</strong> in place of using <strong>let</strong> and <strong>const</strong></li>
                <li>Since <strong>const</strong> is the strictest way to declare a variable, use <strong>const</strong>
                    and switch it to <strong>let</strong> if needed</li>
            </ul>
        </div>

        <div>
            <h3>3. Quiz: Using Let and Const (1-1)</h3>
            <ul>
                <li>A counter in a for loop is a good example of when to use <strong>let</strong></li>
            </ul>
        </div>

        <div>
            <h3>4. Template Literals</h3>
            <ul>
                <li><strong>Template literals</strong> are essentially string literals that include embedded
                    expressions</li>
                <ul>
                    <li>Denoted with back ticks (` `) instead of single quotes (' ') or double quotes (" "), template
                        literals can contain placeholders which are represented using <strong>${expression}</strong></li>
                    <li>Template literals make it <em>much easier</em> to build strings</li>
                </ul>
            </ul>
        </div>

        <div>
            <h3>5. Quiz: Build an HTML Fragment (1-2)</h3>
            <ul>
                <li>Completed template literal exercise</li>
            </ul>
        </div>

        <div>
            <h3>6. Destructuring</h3>
            <ul>
                <li><strong>Destructuring</strong> borrows inspiration from languages like Perl and Python by allowing
                    you to specify the elements you want to extract from an array or object <em>on the left side of an
                        assignment</em></li>
            </ul>
        </div>

        <div>
            <h3>7. Quiz: Destructuring Arrays (1-3)</h3>
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">More
                        info on destructuring</a></li>
            </ul>
        </div>

        <div>
            <h3>8. Object Literal Shorthand</h3>
            <ul>
                <li>You can remove duplicate variable names from object properties if the properties have the same name
                    as the variables being assigned to them</li>
                <li>Having the <strong>function</strong> keyword in a method is redundant and now can be dropped in ES6</li>
            </ul>
        </div>

        <div>
            <h3>9. Lesson 1 Checkup</h3>
            <ul>
                <li>Watched video clip</li>
            </ul>
        </div>

        <div>
            <h3>10. Iteration</h3>
            <ul>
                <li><strong>for...of loop</strong> is a loop that iterates over iterable objects</li>
            </ul>
        </div>

        <div>
            <h3>11. Family of For Loops</h3>
            <ul>
                <li>The biggest downside of a for loop is having to keep track of <strong>the counter</strong> and
                    <strong>exit condition</strong></li>
                <li>The for...in loop improves upon the weaknesses of the for loop by eliminating the counting logic
                    and exit condition, but still have to deal with the issue of using an <strong>index</strong> to
                    access the values of the array</li>
            </ul>
        </div>

        <div>
            <h3>12. For...of Loop</h3>
            <ul>
                <li>The <strong>for...of loop</strong> is used to loop over any type of data that is <em>iterable</em></li>
            </ul>
        </div>

        <div>
            <h3>13. Quiz: Writing a For...of Loop(1-4)</h3>
            <ul>
                <li>Completed exercise using a for...of loop</li>
            </ul>
        </div>

        <div>
            <h3>14. Spread... Operator</h3>
            <ul>
                <li>The <strong>spread operator</strong>, written with three consecutive dots (...), is new in ES6 and
                    gives you the ability to expand, or <em>spread</em>, iterable objects into multiple elements</li>
            </ul>
        </div>

        <div>
            <h3>15. ...Rest Parameter</h3>
            <ul>
                <li>The <strong>rest parameter</strong>, also written with three consecutive dots (...), allows you to
                    represent an indefinite number of elements as an array</li>
                <li>Another use case for the rest parameter is when you're working with variadic functions</li>
                <li><strong>Variadic functions</strong> are functions that take an indefinite number of arguments</li>
                <li>In previous versions of JavaScript, this type of function would be handled using the arguments
                    object</li>
                <li>The arguments object is an array-like object that is available as a local variable inside all
                    functions</li>
                <li>Using the rest parameter makes the function both more concise and and easier to read</li>
            </ul>
        </div>

        <div>
            <h3>16. Quiz: Using the Rest Parameter (1-5)</h3>
            <ul>
                <li>Completed exercise</li>
            </ul>
        </div>

        <div>
            <h3>17. Lesson 1 Summary</h3>
            <ul>
                <li>Watched video clip</li>
            </ul>
        </div>

    </div>

    <div class="section">
        <h2 id="functions"><span>#</span> Functions</h2>
        <div>
            <h3>1. Updates to Functions</h3>
            <ul>
                <li>New way to write functions called <strong>arrow functions</strong></li>
                <li>A new keyword called <strong>class</strong></li>
            </ul>
        </div>

        <div>
            <h3>2. Arrow Functions</h3>
            <ul>
                <li><strong>Arrow functions</strong> are very similar to regular functions in behavior, but are quite
                    different syntactically</li>
                <li>The <strong>map()</strong> method creates a new array with the results of calling a provided
                    function on every element in the calling array</li>
                <li>There are only a few steps for converting the existing 'normal' function into an arrow function:</li>
                <ul>
                    <li>remove the function keyword</li>
                    <li>remove the parentheses</li>
                    <li>remove the opening and closing curly braces</li>
                    <li>remove the return keyword</li>
                    <li>remove the semicolon</li>
                    <li>add an arrow (=>) between the parameter list and the function body</li>
                </ul>
            </ul>
        </div>

        <div>
            <h3>3. Using Arrow Functions</h3>
            <ul>
                <li>Regular functions can be either <strong>function declarations</strong> or <strong>function
                        expressions</strong>, however arrow functions are always <strong>expressions</strong></li>
                <li>Full name is "arrow function expressions", so they can only be used where an expression is valid,
                    this includes being:</li>
                <ul>
                    <li>stored in a variable,</li>
                    <li>passes as an argument to a function,</li>
                    <li>and stored in an object's property</li>
                </ul>
                <li>The concise syntax (a single expression as the function body):</li>
                <ul>
                    <li>has no curly braces surrounding the function body</li>
                    <li>and automatically returns the expression</li>
                </ul>
                <li>If you need more than just a single line of code in your arrow function's body, then you can use
                    the "block body syntax"</li>
                <li>Important things to keep in mind with the block syntax:</li>
                <ul>
                    <li>it uses curly braces to wrap the function body</li>
                    <li>and a return statement needs to be used to actually return something from the function</li>
                </ul>
            </ul>
        </div>

        <div>
            <h3>4. Quiz: Convert Function into an Arrow Function (2-1)</h3>
            <ul>
                <li>Completed exercise</li>
            </ul>
        </div>

        <div>
            <h3>5. Arrow Functions Recap</h3>
            <ul>
                <li>The way arrow functions handle "this" keyword is different from regular functions</li>
            </ul>
        </div>

        <div>
            <h3>6. Arrow Functions and the "this" Keyword</h3>
            <ul>
                <li>How "this" works in an arrow function is based on where it is in the code</li>
            </ul>
        </div>

        <div>
            <h3>7. "this" and Regular Functions</h3>
            <ul>
                <li>The value of the <strong>this</strong> keyword is based completely on how its function (or method)
                    is called</li>
                <li>Determining the <strong>this</strong> binding for an executing function requires finding the
                    direct-call-site of that function</li>
                <li>Once examined, four rules can be applied to the call-site, in this order of precednce:</li>
                <ol>
                    <li>Called with <strong>new</strong>? Use the newly constructed object</li>
                    <li>Called with <strong>call</strong> or <strong>apply</strong> (or <strong>bind</strong>)? Use the
                        specified object</li>
                    <li>Called with a context object owning the call? Use the context object</li>
                    <li>Default: <strong>undefined</strong> in <strong>strict mode</strong>, global object otherwise</li>
                </ol>
                <li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md"
                        target="_blank">More on "this"</a></li>
            </ul>
        </div>

        <div>
            <h3>8. "this" and Arrow Functions</h3>
            <ul>
                <li>With regular functions, the value of <strong>this</strong> is set based on <em>how the function is
                        called, while with arrow functions, the value is based on <em>the function's surrounding
                            context</em></em></li>
            </ul>
        </div>

        <div>
            <h3>9. Default Function Parameters</h3>
            <ul>
                <li><strong>Default function parameters</strong> are quite easy to read since they're placed in the
                    function's parameter list</li>
                <li>To create a default parameter, you add an equal sign (<strong>=</strong>) and then whatever you
                    want the parameter to default to if an argument is not provided</li>
            </ul>
        </div>

        <div>
            <h3>10. Defaults and Destructuring</h3>
            <ul>
                <li>You can combine default function parameters with destructuring to create some pretty powerful
                    functions</li>
                <li>Unless you've got a strong reason to use array defaults with array destructuring, go with object
                    defaults with object destructuring</li>
            </ul>
        </div>

        <div>
            <h3>11. Quiz: Using Default Function Parameters (2-2)</h3>
            <ul>
                <li>Completed exercise</li>
            </ul>
        </div>

        <div>
            <h3>12. Class Preview</h3>
            <ul>
                <li>There are a bunch of new keywords and syntax to play with when creating JavaScript classes</li>
                <li>Before jumping into the specifics of how to write JavaScript classes, it is important to point out
                    a rather confusing part about JS compared with class-based languages, see next section regarding
                    classes</li>
            </ul>
        </div>

        <div>
            <h3>13. JavaScript's Illusion of Classes</h3>
            <ul>
                <li>ES6 introduces new keywords like class, super, extends but JS still uses functions and prototypal
                    inheritance under the hood</li>
                <li>Now we have a new cleaner way to write the same functionality</li>
                <li>JavaScript is <em>not</em> a class based language, it uses functions to create objects and links
                    objects together by prototypal inheritance</li>
            </ul>
        </div>

        <div>
            <h3>14. JavaScript Classes</h3>
            <ul>
                <li>ES5 "Class" Recap:</li>
                <ul>
                    <li>the constructor function is called with the <strong>new</strong> keyword</li>
                    <li>the constructor function, by convention, starts with a capital letter</li>
                    <li>the constructor function controls the setting of data on the objects that will be created</li>
                    <li>"inherited" methods are placed on the constructor function's prototype object</li>
                </ul>
                <li>Keep these in mind as we look at how ES6 classes work because, remember, ES6 classes set up all of
                    this for you under the hood</li>
            </ul>
        </div>

        <div>
            <h3>15. Convert a Function to a Class</h3>
            <ul>
                <li>Watched video clip and coded along</li>
            </ul>
        </div>

        <div>
            <h3>16. Working with JavaScript Classes</h3>
            <ul>
                <li>Class is just a function, it is not a new type that has been added to JavaScript!</li>
                <li>Methods that appear in the class definition are placed on the class's prototype object and a class
                    is just a function</li>
                <li>To add a static method, the keyword <strong>static</strong> is placed in front of the method name</li>
                <li>Things to look out for when using classes:</li>
                <ol>
                    <li><strong>class</strong> is not magic, the keyword brings with it a lot of mental constructs from
                        other, class-based languages, it does not magically add this functionality to JavaScript
                        classes</li>
                    <li><strong>class</strong> is a mirage over prototypal inheritance</li>
                    <li>Using classes requires the use of <strong>new</strong></li>
                </ol>
            </ul>
        </div>

        <div>
            <h3>17. Super and Extends</h3>
            <ul>
                <li>The <strong>extends</strong> keyword is used to create a "subclass", and to get from the "subclass"
                    to the parent class, the <strong>super</strong> keyword is used</li>
                <li><strong>super</strong> can be used in two different ways: as a function and as an object!</li>
            </ul>
        </div>

        <div>
            <h3>18. Extending Classes from ES5 to ES6</h3>
            <ul>
                <li>With the older ES5 another constructor function is written to create the "subclass", then have to
                    set the function's prototype to the base classes prototype, and finally remake the connection
                    between constructor property and the original constructor function</li>
                <li>ES6 uses the <strong>extends</strong> and <strong>super</strong> keywords to achieve the same thing</li>
            </ul>
        </div>

        <div>
            <h3>19. Working with JavaScript Subclasses</h3>
            <ul>
                <li>There is a lot less setup code and it's a lot cleaner syntax to create a subclass using class,
                    super, and extends</li>
                <li>Under the hood, the same connections are made between functions and prototypes</li>
                <li>In a subclass constructor function <strong>super</strong> must be called before <strong>this</strong>
                    can be used</li>
            </ul>
        </div>

        <div>
            <h3>20. Quiz: Building Classes and Subclasses (2-3)</h3>
            <ul>
                <li>Completed exercise</li>
            </ul>
        </div>

        <div>
            <h3>21. Lesson 2 Summary</h3>
            <ul>
                <li>Watched video clip</li>
            </ul>
        </div>

    </div>

    <div class="section">
        <h2 id="builtins"><span>#</span> Built-ins</h2>
        <div>
            <h3>1. New Built-ins</h3>
            <ul>
                <li>Sets, maps, and promises are some of the new built-ins of ES6</li>
            </ul>
        </div>

        <div>
            <h3>2. Symbols Intro</h3>
            <ul>
                <li>Symbol is the new primitive type that comes with ES6</li>
                <li><strong>Symbol</strong> is a unique identifier, most often used to uniquely idenify properties
                    within an object</li>
            </ul>
        </div>

        <div>
            <h3>3. Symbols</h3>
            <ul>
                <li>A <strong>symbol</strong> is a unique and immutable data type that is often used to identify object
                    properties</li>
                <li>To create a symbol, you write <strong>Symbol()</strong> with an optional string as its <em>description</em></li>
            </ul>
        </div>

        <div>
            <h3>4. Iteration & Iterable Protocols</h3>
            <ul>
                <li>The <strong>iterable protocol</strong> is used for defining and customizing the iteration behavior
                    of objects</li>
                <li>The <strong>iterator method</strong>, which is available via the constant <strong>[Symbol.iterator]</strong>,
                    is a zero arguments function that returns an iterator object</li>
                <li>The <strong>iterator protocol</strong> is used to define a standard way that an object produces a
                    sequence of values, this means you now have a process for defining how an object will iterate</li>
                <li>An object becomes an iterator when it implements the <strong>.next()</strong> method, it is a zero
                    arguments function that returns an object with two properties:</li>
                <ol>
                    <li><strong>value</strong>: the data representing the next value in the sequence of values within
                        the object</li>
                    <li><strong>done</strong>: a boolean representing if the iterator is <em>done</em> going through
                        the sequence of values</li>
                    <ul>
                        <li>If done is <em>true</em>, then the iterator has reached the end of its sequence of values</li>
                        <li>If done is <em>false</em>, then the iterator is able to produce another value in its
                            sequence of values</li>
                    </ul>
                </ol>
            </ul>
        </div>

        <div>
            <h3>5. Sets</h3>
            <ul>
                <li><strong>Set</strong> is a new built-in object that behaves like a mathematical set and works
                    similarly to an array</li>
                <li>The biggest differences between a set and an array are:</li>
                <ul>
                    <li>Sets are not indexed-based - you do not refer to items in a set based on their position in the
                        set</li>
                    <li>items in a Set can't be accessed individually</li>
                </ul>
            </ul>
        </div>

        <div>
            <h3>6. Modifying Sets</h3>
            <ul>
                <li>You can modify a set by using <strong>.add()</strong> and <strong>.delete()</strong></li>
                <li>To delete all the items from a Set, use the <strong>.clear()</strong> method</li>
                <li><strong>.add()</strong> returns the Set if an item is successfully added, while <strong>.delete()</strong>
                    returns a Boolean (true or false) depending on successful deletion</li>
            </ul>
        </div>

        <div>
            <h3>7. Working with Sets</h3>
            <ul>
                <li>Sets can't be accessed by their index like an array, so you use the <strong>.size</strong> property instead of <strong>.length</strong> property to get the size of the Set</li>
                <li>Use the <strong>.has()</strong> method to check if an item exists in a Set, the return value will be a Boolean</li>
                <li>Use the <strong>.values()</strong> method to return the values in a Set, the return value of the <strong>.values()</strong> method is a <strong>SetIterator</strong> object</li>
            </ul>
        </div>

        <div>
            <h3>8. Sets & Iterators</h3>
            <ul>
                <li></li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2 id="developerfu"><span>#</span> Professional Developer-fu</h2>
        <div>
            <h3></h3>
            <ul>
                <li></li>
            </ul>
        </div>
    </div>

</body>

</html>